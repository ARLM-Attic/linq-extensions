<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" >
<head>
    <title>Untitled Page</title>
    <link rel="stylesheet" type="text/css" href="http://tomasp.net/files/articles.css" />
</head>
<body>

<h1>Calculating with Infinite Sequences in C#</h1>
<div style="margin:10px; float:right;">
  <a href="mandel.png" target="_blank"><img src="mandel_sm.png" style="border:0px" alt="Mandelbrot set" /></a>
</div>
<p>In my <a href="!!!!!!!!!!!!!!! TODO !!!!!!!!!!!!!!!">previous article</a> we shortly discussed <em>lazy evaluation</em>
  and looked at how it can be simulated in C#. We implemented a class <code>Lazy&lt;T&gt;</code>, which
  represents a value that can be evaluated on demand - this means that the class "knows" how to calculate
  the result, but doesn't actually calculate it until it is really needed in the program. One very interesting
  data structure known from functional programming that can be implemented using this lazy cell is <em>lazy list</em>.
  Element in a lazy list stores the value associated with the element (for example a number) and knows how to calculate the next element
  in the list, but it is <em>lazy</em> meaning that the next element is not calculated until its value is accessed by the program.   
  The most interesting aspect of lazy lists is that they can be used for representing infinite sequences - this is 
  possible because the elements are calculated only when needed and so the list will always store only
  finite number of elements, but it will still be able to calculate next element if it is needed.</p>

<p>In this article I will show that the lazy lists as described in this introduction can be very well
  implemented using <code>IEnumerable&lt;T&gt;</code> type in C# and I will also demonstrate how LINQ
  query operators can be used to manipulate with infinite lists. Finally, we will look at implementation
  of Mandelbrot set program (you can see it on the screenshot) using the techniques described in the article.</p>

<h2>Introducing IEnumerable</h2>  
<p>Most of you probably know that .NET sequences can be represented using <code>IEnumerable&lt;T&gt;</code>
  interface - it can be used for enumerating items in arrays, lists, dictionaries and other standard
  collections as well as your custom collections. In C# this interface is also very often used together 
  with the <code>foreach</code> statement. Let's first remind what the most important methods 
  of this interface are (other methods including those inherited from <code>IDisposable</code> are not important for our examples):</p>
<pre>
interface IEnumerable&lt;T&gt; : IDisposable&lt;T&gt;
{
  public void Reset();
  public bool MoveNext();
  public T Current { get; }
  // ... other methods omitted ...
}
</pre>  
<p>The enumeration over data structure is done using the three members shown in the previous code example.
  First of all, the <code>Reset</code> method is called to move the enumerator before the first element.
  After that the <code>MoveNext</code> method moves enumerator to the next element in the sequence or 
  returns <code>false</code> if there are no more elements. During the enumeration, the current element
  can be accessed using the <code>Current</code> property.</p>
<p>Until version C# 2.0 you had to provide an implementation of this interface when you wanted to allow
  enumeration over your own collection. This introduced unnecessary complexity, so in the C# 2.0
  the <code>yield return</code> was introduced. Using this keyword, implementing a custom enumerator is
  just as easy as iterating over all the elements in a loop. Let's look at a very simple example:
</p>
<pre>
class MyList {
  int[] elements;
  
  IEnumerable&lt;int&gt; GetEnumerable() {
    for(int i=0; i&lt;elements.Length; i++)
      yield return elements[i];
  }
}
</pre>
<p>In this example you can see a method that returns implementation of <code>IEnumerable&lt;T&gt;</code>,
  which can be used for enumerating all elements in an array. The body of this method
  doesn't however return explicit implementation of the interface and instead uses <code>yield return</code> keyword,
  which is compiled into a such interface implementation by the C# compiler.
  Understanding what the code does is easy (it just iterates over all the elements and 
  returns every single element from the array using <code>yield return</code>), but understanding 
  how the code is used to implement the <code>IEnumerable&lt;T&gt;</code> interface would require another
  article. The important thing to understand is what happens when you call the method implemented using
  <code>yield return</code> as in the following example:</p>
<pre>
var en = myList.GetEnumerable();
</pre>  
<p>When you perform this call, the object generated by the compiler is created, but not a single line
  of the code that you wrote is executed so far! The code starts executing after we call <code>MoveNext</code>
  method. It steps to the first occurence of <code>yield return</code> and then "leaves" the method and 
  the control is transferred back to the caller of <code>MoveNext</code>. Of course it is not possible to
  step outside from an executing method and then "jump" back (keeping the original state of variables in the 
  method), so the compiler has to translate the code in the method to a class, lift the variables to
  a class members and generate a code that implements a transition between each two uses of <code>yield return</code>
  (for those who are interested in details - the C# compiler translates the code of the method to
  a state machine where every use of <code>yield return</code> representes a single state).</p>

<h2>Infinite Sequences and LINQ Query Operators</h2>
<p>The most important thing that I wanted to point out in the previous section is that the entire body of the 
  method is not executed unless the caller repeatedly calls <code>MoveNext</code> until it reaches the end and 
  the method returns <code>false</code>. This means that if we write a code that would execute forever, but
  with a call to <code>yield return</code> inside the code, it will not cause an infinite loop and, in fact, can be 
  sometimes quite useful and interesting. Let's look at the simplest possible example:</p>  
<pre>
IEnumerable&lt;int&gt; GetNumbers()
{
  int i = 0;
  while(true) yield return i++;
}

// Create an infinite sequence of integers
var nums = GetNumbers();
</pre>
<p>The <code>GetNumbers</code> method in the previous code returns an implementation of <code>IEnumerable&lt;int&gt;</code>
  that can be used for looping over all integers starting from <code>0</code> (since <code>int</code> has a limited range
  the value will overflow and start from <code>Int32.MinValue</code> eventually, but this is not important now).
  Later in the example we call the method and create a variable <code>nums</code> that we will use in the next
  examples, but this call just creates a value that can return numbers when we call <code>MoveNext</code> - it
  doesn't cause any infinite loops alone. You still have to be careful when working with this value, because if you 
  gave it as an argument to <code>foreach</code> it would cause an infinite loop, because <code>foreach</code> would
  continue calling <code>MoveNext</code> until it would return <code>false</code> which will never happen in case of
  sequence generated by <code>GetNumbers</code> method!</p>
<p>Now, let's look what will happen when we use LINQ query operators with the infinite sequence that we just declared.
  In the following example we use <code>Where</code> extension method to filter only even numbers and 
  <code>Select</code> extension method to calculate square of the filtered (even) numbers:</p>
<pre>
var sq = GetNumbers().Where(n => n % 2 == 0).Select(n => n * n);
</pre>
<p>We can indeed use C# 3.0 query comprehension syntax (which is just a shorthand for the earlier):</p>
<pre>
var sq = from n in GetNumbers() where n % 2 == 0 select n * n;
</pre>
<p>Will this cause an infinite loop? No, because we're still working with lazy sequences represented using
  <code>IEnumerable&lt;int&gt;</code>. The call to the <code>Where</code> query operator returns 
  a new sequence with a <code>MoveNext</code> method that, when called, iterates over the underlying sequence
  until it finds an even number and then stops. Similarly, a single step in the sequence returned by the 
  <code>Select</code> operator just takes one element and calculates its square. The only remaining problem
  is that we have to be careful when printing the sequence, because we can't simply use <code>foreach</code>.
  Luckily, LINQ provides <code>Take</code> query operator, which returns a sequence that will take first <em>X</em>
  elements and then stop, so we can write the following code:</p>
<pre>
foreach(int n in sq.Take(10))
  Console.WriteLine(n);
</pre>  
<p>Clearly, <code>Where</code> and <code>Select</code> are not all query operators that you can use with
  infinite sequences, but you have to be careful - for example <code>Aggregate</code>, <code>Reverse</code> 
  or any join operators need to iterate over all the elements, which isn't possible when working with infinite sequences. Finally, you can implement your
  own iterators to perform operations that are not covered by standard LINQ query operators - for more information
  you can look at C# Developer Center article <a href="http://msdn2.microsoft.com/en-us/vcsharp/bb264519.aspx">Custom Iterators</a> 
  from Bill Wagner.</p>

<h2>Generating Infinite Sequences</h2>
<p>So far we generated sequences explicitly using <code>yield return</code>, which is perfect, but sometimes
  it may be useful write a reusable function that hides the <code>yield return</code> and provides
  higher level of abstraction. For example, many sequences can be described in an inductive way - by
  giving the first element and a function that takes a value as an argument and calculates the next
  value in a sequence. This function can be implemented using the C# 3.0 <code>Func&lt;A0,T&gt;</code> delegate type:</p>
<pre>
IEnumerable&lt;T&gt; Generate&lt;T&gt;(T initial, Func&lt;T, T?&gt; next) 
    where T : struct {
  T? val = initial;
  while (val.HasValue) {
    yield return val.Value;
    val = next(val.Value);
  }
}
</pre>
<p>The <code>Generate</code> function is generic, so it can generate sequences of any type (the type is
  just limited to a value type, so we can use C# nullable types). The first argument of the function is
  the initial value of type <code>T</code>. The second argument is a function that accepts a value of <code>T</code>
  as an argument and returns a <code>T?</code>, which means that it can return <code>null</code> or a valid value.
  The <code>null</code> return value is used to denote the end of a sequence and as you can see in the body,
  the condition in the <code>while</code> loop tests if the returned nullable type contains a value.
  This means that the <code>Generate</code> function can be used for generating both infinite and finite sequences.</p>
<p>The following code shows a few sequences that can be written in a very compact way using <code>Generate</code> method:</p>
<pre>
// All positive integers: 1, 2, 3, 4, ...
var nums = Generate(0, n =&gt; n + 1);

// Powers of two: 1, 2, 4, 8, 16, 32, ...
var pow2 = Generate(1, n =&gt; n * 2);

// Finite sequence of powers of two that fit into an 'int' type
// When we get to a number that would overflow, we return 'null'
var intpow2 = Generate(1, n =&gt; {
    if (n &gt; Int32.MaxValue / 2)
      return (int?)null;
    else
      return (int?)(n * 2);
  });</pre>
<h2>Example - Mandelbrot Set Using Infinite Sequences</h2>
<p>In the final example we will use infinite sequence to draw a famous Mandelbrot set. When drawing the image shown
  on the screenshot above, we will need to calculate a color for every pixel separately and this operation
  can be implemented using sequences, which also makes the code easier to read, because the implementation
  doesn't hide how the Mandelbrot set is defined mathematically. We'll get to calculation of the color soon, but
  first, we need to build a palette with colors that you can see on the screenshot. To do this we first
  define two more utility functions for working with <code>IEnumerable&lt;T&gt;</code>:</p> 
<pre>
IEnumerable&lt;int&gt; Range(int from, int to) {
  for (int i = from; i &lt;= to; i++) yield return i;
}

IEnumerable&lt;T&gt; Concat&lt;T&gt;(params IEnumerable&lt;T&gt;[] args) {
  foreach (var en in args)
    foreach (var el in en) yield return el;
}
</pre>
<p>The first method called <code>Range</code> simply returns all integers in a specified range. The second function
  is used for concatenation of sequences. It takes any number of sequences and iterates step by step over
  all the given sequences. Now let's look how the palette is generated:</p>
<pre>
Color[] Palette {
  get {
    return Seq.Concat(
        Seq.Range(0, 127).Select(n =&gt; 
          Color.FromArgb(0, n * 2, 0)),
        Seq.Range(0, 127).Select(n =&gt; 
          Color.FromArgb(0, 255 - n * 2, n)) ).ToArray();
  }
}      
</pre>
<p>As you saw on the screenshot, the palette starts with black color, then blends to a blue and 
  finally changes to a green color. This means that we can generate it by concatenating two 
  transitions (from black to blue and from blue to green) and this is exactly what the previous 
  code does. It generates two ranges of integers and uses these numbers to generate colors 
  using the <code>Select</code> query operator. The two ranges are then concatenated and
  the result is converted to an array and returned.</p>

<p>Now we can get back to the Mandelbrot set. As already mentioned, we will first write a code that
  generates (in theory) infinite sequence of numbers and then use it to choose the color. 
  The calculation of the sequence takes two arguments that specify the <em>x</em> and <em>y</em> coordinates
  of the point that we're processing. The sequence is calculated inductively, which means that
  we start with some initial value and then use the current value to calculate a new one.
  We already discussed this kind of sequences and we can use the <code>Generate</code> method 
  to implement it easily. </p>
<p>The value in our example is represented using <code>PointF</code> type. We use a zero point 
  as the initial value and in every step we will first test if <code>x^2 + y^2</code> is larger or equal than two.
  If yes we have reached the end of the sequence (because the value is out of the specified 
  range), otherwise we have to calculate the new value
  (using an equation for multiplication and addition of complex numbers), because we still
  can't tell if the value will eventually escape the range or not.</p>
<pre>
private static IEnumerable&lt;PointF&gt; GenerateMandel(float x, float y)
{
  var init = new PointF(0.0f, 0.0f);
  return Generate(init, (t) =&gt; {
      float x2 = t.X * t.X, y2 = t.Y * t.Y;
      if (Math.Sqrt(x2 + y2) &gt;= 2)
        return null; 
      else 
        return new PointF(x2 - y2 + t.X, 2 * t.X * t.Y + t.Y);
    });
}
</pre>
<p>As mentioned earlier, we used the <code>Generate</code> method to build the sequence. 
  You can see that using anonymous functions from C# 3.0 makes this code really compact - because 
  the computation of the next value is a bit longer we use anonymous function with statement
  block as a body - this means that the code is wrapped in curly braces and uses a <code>return</code>
  statement.</p>
<p>Now we know how to calculate a sequence for every point and the only remaining problem
  is how to draw the bitmap using the sequence. We want to determine if the sequence will at some
  time in the future leave the specified range - if this happens then we know how many iterations
  it took and we can choose a color according to the iteration, however when the sequence still
  stays in the specified range we don't know if it will ever leave it or not, so we could iterate
  forever! To avoid this we just stop calculating after 100 iterations and choose the lightest (green) color.</p>
<p>To count the number of iteration we would normally use the <code>Count</code> query operator,
  but we also need to limit the maximal number of iterations to some maximal number. To do this
  we can write the following helper method that uses <code>TakeWhile</code> to read values
  from the sequence until the counter reaches zero and then uses <code>Count</code> to
  get the number of elements in the sequence (also note that we don't need the argument of the 
  anonymous function, so we just use underscore as a variable name):</p>  
<pre>
int CountMax&lt;T&gt;(this IEnumerable&lt;T&gt; en, int max) {
  return en.TakeWhile(_ =&gt; max-- &gt; 0).Count();
}
</pre>
<p>Using this <code>CountMax</code> method we can now implement the code that draws the Mandelbrot
  set. We first generate the palette and initialize variables that determine which part of the
  set is drawn. After that we also use a method <code>InitBitmap</code> (it will be discussed shortly) 
  that generates a bitmap of specified size by calling a given function to get a color for every
  single pixel. In the anonymous function that returns the color we first calculate a point
  that we want to analyze and then call <code>GenerateMandel</code> to generate a sequence for this
  specific point. Then we use <code>CountMax</code> to calculate how much iterations did the sequence
  perform and finally we get a color for the performed number of iterations.</p>
<pre>
var colors = Palette;

// Initialize a location and a zoom of the set
float dx = 0.005f, dy = 0.005f;
float xmin = -2.0f, ymin = -1.3f;

// Generate bitmap using given function..
var mandel = InitBitmap(this.Width, this.Height, (x, y) =&gt; {
    float xs = xmin + x * dx, ys = ymin + y * dy;
    
    // Calculate number of iterations
    int count = GenerateMandel(xs, ys).CountMax(100);
    
    // Get a color for the calculated # of iterations
    int val = (int)((count / 100.0) * 255.0);
    return colors[val];
  });
</pre>
<p>As already mentioned, the code uses <code>InitBitmap</code> method, which takes the function
  to calculate the color for a pixel as the third argument. We use C# 3.0 anonymous function to implement
  this computation. In the body we first pre-compute the point in the Mandelbrot set coordinates.
  Using this point we generate the sequence of iterations and count the number (with 100 as a maximum).
  Finally, we just choose a color from the palette and return it as a result of the anonymous function.</p>
<p>As a last thing, we will look at the implementation of <code>InitBitmap</code>. It is quite simple - it just iterates
  over all the pixels in the bitmap and calls the given function to calculate the color (indeed,
  it is more efficient to use the C# unsafe code to do this - this implementation can be found
  in the code that is attached for download).</p>
<pre>
Bitmap InitBitmap(int width, int height, Func&lt;int, int, Color&gt; f) {
  Bitmap b = new Bitmap(width, height);
  for (int x = 0; x &lt; this.Width; x++)
    for (int y = 0; y &lt; this.Height; y++)
      b.SetPixel(x, y, f(x,y));
  return b;        
}
</pre>

<h2>Conclusion</h2>
<p>In this article we looked at one not widely know aspect of the <code>IEnumerable&lt;T&gt;</code> type,
  which is the fact that it can be used to represent infinite sequences of values. We also demonstrated
  that it is possible to use some of the LINQ query operators including the query comprehension syntax
  for working with these infinite data structures. I also demonstrated that it is possible to use C# 3.0
  anonymous functions when manipulating or generating these types of sequences. Finally, we looked at one
  more complicated example that used the described technique and several new C# 3.0 language features to 
  build an easier to understand implementation of a program for drawing the famous Mandelbrot set in a way
  that is closer to the original mathematical definition of the problem.</p>


</body>
</html>
